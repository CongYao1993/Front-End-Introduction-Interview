## 1. Cookie / sessionStorage / localstorage

| <div style="width:100px;"></div> | Cookie                                                                         | localStorage                             | sessionStorage                                                                                                             |
| -------------------------------- | ------------------------------------------------------------------------------ | ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| 使用场景                         | 用于客户端与服务器之间传递少量信息                                             | 持久化缓存数据，比如页面的默认偏好配置等 | 一次性临时数据保存，同一会话的多个页面传递数据                                                                             |
| 生命周期                         | 默认关闭标签或浏览器后删除；可以设置 Expires 或 Max-Age 指定的一段时间后被删除 | 长期保留，除非被清除                     | 仅在当前会话下有效，关闭标签或浏览器后被清除                                                                               |
| 作用域                           | 同源或者包含子域名                                                             | 同源，子域无法继承父域的 localStorage    | 不能在多个窗口或标签页之间共享数据，但是同一个会话的新页面（通过 window.open 或链接打开新页面）会复制前一页 sessionStorage |
| 存放数据大小                     | 4KB                                                                            | 5MB                                      | 5MB                                                                                                                        |
| 存放位置                         | 浏览器/服务端                                                                  | 浏览器                                   | 浏览器                                                                                                                     |

### 1.1 Cookie

Cookie 是服务器发送到浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时，携带在 HTTP 头部并发送到服务器上。

```
响应头部：Set-Cookie: <cookie名>=<cookie值>
请求头部：Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly; SameSite=Strict
```

- `Domain`：指定了哪些主机可以接受 Cookie。如果不指定，该属性默认为同一主机设置 Cookie，不包含子域名。如果指定了 Domain，则一般包含子域名。
- `Path`：设置 Cookie 的生效路径，子路径也会被匹配。Path=/;表示该域名下所有路径都会被匹配。
- `Secure`：cookie 只通过 https 协议传输，可以预防中间人攻击。
- `HttpOnly`：阻止通过 JavaScript document.cookie 访问 cookie，从而一定程度上遏制 XSS 攻击等。
- `SameSite`：允许服务器要求某个 cookie 在跨站请求时不会被发送，从而可以阻止 CSRF 攻击。

原生的 Cookie 接口不友好，可以用 js-cookie 插件。

### 1.2 Web Storage

Web Storage 定义了两个对象: localStorage 和 sessionStorage。前者是永久存储机制,而后者是跨会话的存储机制。

- localStorage 在 iOS Safari、chrome 和 UC 浏览器中的隐私模式（也叫无痕模式）下无法使用
- 页面间传参，通过 url 或者 pushState 的 state 更好

**如何设置 localstorage 过期时间？**

localstorage 原生是不支持设置过期时间，只能自己来封装一层逻辑来实现：

```javascript
function set(key, value) {
  var curtime = new Date().getTime(); // 获取当前时间
  localStorage.setItem(key, JSON.stringify({ val: value, time: curtime })); // 转换成json字符串序列
}
function get(key, exp) {
  // exp是设置的过期时间
  var val = localStorage.getItem(key); // 获取存储的元素
  var dataobj = JSON.parse(val); // 解析出json对象
  if (new Date().getTime() - dataobj.time > exp) {
    // 如果当前时间-减去存储的元素在创建时候设置的时间 > 过期时间
    console.log("expires"); //提示过期
  } else {
    console.log("val=" + dataobj.val);
  }
}
```

## 2. 跨域及解决方案

### 2.1 同源策略

如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。即便两个不同的域名指向同一个 ip 地址，也非同源。

同源策略的限制：

- DOM 层面：不同源的 JavaScript 脚本无法操作当前 DOM 对象；
- 数据层面：不同源的站点无法读取当前站点的 Cookie、localStorage 等数据。
- 网络层面：无法通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

不同源的操作就会产生跨域问题。

### 2.2 jsonp

通常为了减轻 web 服务器的负载，我们把 js、css，img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建 script，再请求一个带参网址实现跨域通信。

jsonp 缺点：只能实现 get 一种请求。

```html
<script>
  var script = document.createElement("script");
  script.type = "text/javascript";

  // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
  script.src =
    "http://www.domain2.com:8080/login?user=admin&callback=handleCallback";
  document.head.appendChild(script);

  // 回调执行函数
  function handleCallback(res) {
    alert(JSON.stringify(res));
  }
</script>
```

```javascript
// 服务端返回如下，返回时执行全局函数
handleCallback({ status: true, user: "admin" });

// node
var querystring = require("querystring");
var http = require("http");
var server = http.createServer();

server.on("request", function (req, res) {
  var params = qs.parse(req.url.split("?")[1]);
  var fn = params.callback;

  // jsonp返回设置
  res.writeHead(200, { "Content-Type": "text/javascript" });
  res.write(fn + "(" + JSON.stringify(params) + ")");

  res.end();
});

server.listen("8080");
console.log("Server is running at port 8080...");
```

## 5. 进程和线程

一个进程是一个程序的运行实例。启动一个程序时，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程.

- 进程是 CPU 资源分配的最小单位，每一个进程都有一个自己的内存空间。
- 当一个进程关闭之后，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收；
- 进程之间的内容相互隔离。一个进程不会影响到其他进程的。

线程是依附于进程执行的，为了提高进程的执行效率。

- 线程是 CPU 调度的最小单位；
- 线程之间共享进程中的数据等所有资源；
- 进程中的任意线程执行出错，都会导致整个进程的崩溃。
