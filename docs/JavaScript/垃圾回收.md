[MDN 内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management)

[你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)

## 1. 内存管理和垃圾回收

不管什么程序语言，内存生命周期基本是一致的：

- 分配你所需要的内存；
- 使用分配的内存（读、写）；
- 不需要时释放内存。

在 JavaScript 中，通过自动内存管理实现内存分配和闲置资源回收。当我们创建变量（对象，字符串等）时，系统会自动给对象分配对应的内存。每隔一定时间，当系统发现变量不再使用时，会自动释放变量的内存。

垃圾回收（Garbage Collection，简称 GC）即确定哪个变量不会再使用，然后释放它占用的内存。

## 2. 垃圾回收标记策略

垃圾回收标记策略指跟踪记录哪个变量还会使用，哪个变量不再使用。

浏览器发展史上，用过两种标记策略：引用计数和标记清除。

### 2.1 引用计数

引用计数策略是指，如果一个对象没有引用指向它（0 引用），该对象将会被垃圾回收机制回收。

```javascript
var o = {
  a: {
    b: 2,
  },
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o
// 很显然，没有一个可以被垃圾收集

var o2 = o; // o2 变量是第二个对“这个对象”的引用

o = 1; // 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有

var oa = o2.a; // 引用“这个对象”的 a 属性
// 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
// 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收

oa = null; // a 属性的那个对象现在也是零引用了
// 它可以被垃圾回收了
```

- 优点
  - 当引用值的引用次数为 0 时，可以立即回收垃圾
  - 只需要在引用和失去引用时计数，不需要遍历堆里的所有对象
- 缺点
  - 引用计数需要一个计数器，计数器需要占很大的位置，因为引用数量的上限是不确定的
  - 循环引用无法回收，这也是最严重的

循环引用

```javascript
var o = {};
var o2 = {};
o.a = o2; // o 引用 o2
o2.a = o; // o2 引用 o
```

### 2.2 标记-清除

标记-清除算法是指，一个对象不可达时，表明该对象不再需要，可以进行垃圾回收。

垃圾回收器将定期从根对象（全局 window 对象、文档 DOM 树）开始，找所有从根开始引用的对象，然后找这些对象引用的对象……（深度遍历）。从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript 引擎 在运行垃圾回收的频率上有所差异。

## 3. V8 引擎的垃圾回收策略

V8 内存：

- 64 位下是 1.4G
- 32 位下 700MB
- 但是根据浏览器不同，有些许扩容；Node 情况下会有一些 C++内存扩容

为什么 V8 设计 1.4G 内存？

- 1.4G 对于浏览器脚本来说够用
- 回收的时候是阻塞式的，也就是进行垃圾回收的时候会中断代码的执行。

V8 将堆内存分为新生代和老生代两区域。

为什么要管理内存？

- 减少浏览器的负担：内存过大会让浏览器压力过大，导致浏览器卡顿
- Node 端：如果内存不够，Nodejs 服务就会中断

内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
